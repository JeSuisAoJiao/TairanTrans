#Swift教程 第三部分：元组，协议，委托和表视图


欢迎回到我们的Swift教程系列！

在[第一篇Swift教程](http://www.raywenderlich.com/74438/swift-tutorial-a-quick-start)里,我们学习了Swift语言的基础，并且创建了属于我们自己的小费计算器类。

在[第二篇Swift教程](http://www.raywenderlich.com/74904/swift-tutorial-part-2-simple-ios-app)里，我们为小费计算器工程创建了一个简单的用户界面。

在这第三篇Swift教程中，我们将学习一个Swift引入的一个新的数据类型：元组。

我们也将学习协议，委托，表视图，以及如何在Playgrounds中规范用户界面。

这篇教程补充了[第二篇Swift教程](http://www.raywenderlich.com/74904/swift-tutorial-part-2-simple-ios-app)中遗漏的知识。如果你还没有学习过第二篇教程，请确保你已经下载了上次遗漏的工程案例。

    注意: 在撰写这篇指南以前，我们的理解是我们不能张贴Xcode相关的截图，因为它还处于Beta阶段。因此，我们在确保不会引起相关问题之前，将不会提供截屏。

##开始

到现在为止，我们的小费计算器为每个小费百分比提供了一个参考。然而，一旦你选择了你要付的小费，你必须在你脑中将小费加到账单总额——

你的**calcTipWithTipPct()**方法最好返回两个值：小费数额，包括小费的账单总额。

在Objective-C中，如果你要创建一个具有两个返回值的方法，你要么需要创建一个返回值有两个属性的Objective-C对象，要么你需要返回一个包含两个值的字典。在Swift中，还有一个可选的途径：元组。

现在我们开始耍耍元组感受一下它是如何运作的。在Xcode中创建一个Playground（或者如果你采纳我在[第一篇Swift教程](http://www.raywenderlich.com/74438/swift-tutorial-a-quick-start)中的建议，就只要点击已经保存到dock上的Playground）。在你的Playground中删除所有东西以便我们从一个干净的板块下开始。

##未命名元组

让我们从创建一个叫做**未命名元组**的东西开始。在Playground中输入以下内容：

`let tipAndTotal = (4.00, 25.19)`

这里我们将两个双精度型数值（小费和总额）组合到一个元组类型的值中。这里用到了推断语法因为编译器可以根据你设定的初始值自动识别数据类型。你也可以显式地改写上述代码如下：

`let tipAndTotal:(Double, Double) = (4.00, 25.19)`

如果要访问元组中的单个元素，有两种方案：通过索引访问，通过名字分解。可以在Playground中加上以下代码来试下第一种方案：

tipAndTotal.0
tipAndTotal.1

你将在Playground的侧边栏看到4.0和25.19两个值。通过索引访问可以在必要时候用一下，但是不如通过名字分解来的清晰。可以在Playground中加上以下代码来试下第二种方案：

let (theTipAmt, theTotal) = tipAndTotal
theTipAmt
theTotal

这种语法允许你用一个特殊的名字创建一个新的常量来代表元组中的每个元素。

##命名元组

未命名元组可以使用，但是就像你看到的那样，它需要一些额外的代码来通过名字访问每一项。

当你在声明时为你的元组命名的时候，通常用**命名元组**来代替它会更加方便。可以在Playground中加上以下代码来尝试一下：

let tipAndTotalNamed = (tipAmt:4.00, total:25.19)
tipAndTotalNamed.tipAmt
tipAndTotalNamed.total

正如你看到的这将会更加方便，并且这也是我们在以后的教程当中要用到的。

最后我想要再一次指出你在声明tipAndTotalNamed方法的时候使用推断语法。如果你想要使用显式语法，那么代码会像以下这样：

let tipAndTotalNamed:(tipAmt:Double, total:Double) = (4.00, 25.19)

注意当你使用显式语法的时候，在右手边命名变量是可选的。

##返回元组

现在我们了解了元组的基础知识，现在我们看看在小费计算器中如何使用它们来返回两个值。

在你的playground中添加以下代码：

let total = 21.19
let taxPct = 0.06
let subtotal = total / (taxPct + 1)
func calcTipWithTipPct(tipPct:Double) -> (tipAmt:Double, total:Double) {
  let tipAmt = subtotal * tipPct
  let finalTotal = total + tipAmt
  return (tipAmt, finalTotal)
}
calcTipWithTipPct(0.20)

这是与我们已经接触过的calcTipWithTipPct相同的方法，不同的是它返回的是双精度型的值。它返回(tipAmt:Double, total:Double)。

这里是到目前为止的[playground文件]（http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/Prototype1.playground.zip）。现在清空playground来开始一个新的板块。

##一个完整的原型

这时候，你已经准备好掌握你所学到的知识并且把它整合到**TipCalculatorModel**类中。

但是在你开始修改TipCalculator这个Xcode工程的时候，让我们尝试在playground中进行改变！

将**TipCalculatorModel**类从**TipCalculator**工程中拷贝到这个playground。然后，用和之前同样的方式修改**calcTipWithTipPct**。最后，修改**returnPossibleTips**来返回一个将整型转换为元组的字典而不是将整型转换为双精度型的字典。

看看如果你可以自己计算出这个，这是一个很好的实践。但是如果你陷入困境中，检查以下的破坏分子！

内部的解决方案： TipCalculatorModel - 修改后的

import Foundation
 
class TipCalculatorModel {
 
  var total: Double
  var taxPct: Double
  var subtotal: Double {
    get {
      return total / (taxPct + 1)
    }
  }
 
  init(total:Double, taxPct:Double) {
    self.total = total
    self.taxPct = taxPct
  }
 
  func calcTipWithTipPct(tipPct:Double) -> (tipAmt:Double, total:Double) {
    let tipAmt = subtotal * tipPct
    let finalTotal = total + tipAmt
    return (tipAmt, finalTotal)
  }
 
  func returnPossibleTips() -> [Int: (tipAmt:Double, total:Double)] {
 
    let possibleTipsInferred = [0.15, 0.18, 0.20]
    let possibleTipsExplicit:[Double] = [0.15, 0.18, 0.20]
 
    var retval = Dictionary<Int, (tipAmt:Double, total:Double)>()
    for possibleTip in possibleTipsInferred {
      let intPct = Int(possibleTip*100)
      retval[intPct] = calcTipWithTipPct(possibleTip)
    }
    return retval
 
  }
 
}
 
let tipCalc = TipCalculatorModel(total: 21.19, taxPct: 0.06)
tipCalc.returnPossibleTips()

这里是到目前为止的[playground文件]（http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/SwiftPlayground2.playground.zip）。

这时候，保存这个文件并且重新启动一个新的空的playground。我们接下来将转到这个playground。

##协议

下一步是为你的应用建立一个表格视图的原型。但是在做这件事之前，你需要理解**协议**和**委托**的概念。让我们从协议开始学习。

协议是指详细说明一个协议或者一个接口的方法的清单。在你的playground中加入以下几行代码来理解我所说的内容：

protocol Speaker {
  func Speak()
}

这个协议声明了一个叫做**Speaker**的单一的方法。

遵守这个协议的任何一个类都必须实现这个方法。通过添加两个遵守这个协议的类来练习一下：

class Vicki: Speaker {
  func Speak() {
    println("Hello, I am Vicki!")
  }
}
 
class Ray: Speaker {
  func Speak() {
    println("Yo, I am Ray!")
  }
}

将一个类标记为遵守一个协议，你必须在类名的后面加一个冒号，然后列出协议（当类的名称继承自其它类，如果有的话）。这些类不继承自任何一个其它类，所以你可以仅仅直接列出协议的名称。

同时注意如果你没有引入Speak函数，将导致编译错误。

现在我们尝试将一个类继承自其它类：

class Animal {
}
class Dog : Animal, Speaker {
  func Speak() {
    println("Woof!")
  }
}

在这个例子中，**Dog**继承自**Animal**，所以当你声明**Dog**类时候你在后面加了一个**:**,然后它继承了那个类，然后列出所有的协议。在Swift中你可以只继承一个类，但是你可以遵守任何数量的协议。

##可选的协议

你可以在协议中标记一个方法是否是可选的。通过以下代码替换**Speaker**协议来尝试一下：

@objc protocol Speaker {
  func Speak()
  @optional func TellJoke()
}

如果你想要有一个具有可选方法的协议，你必须给协议加上一个**@objc**标签作为前缀（即使你的类不能兼容objective-C）。然后，你给所有可选方法加上**@optional**标签作为前缀。

注意这里**Person**和**Dog**类没有编译错误，因为新函数是可选的。

在这个例子中，**Ray**和**Vicki**可以说笑话，但很遗憾不是一个**Dog**。所以，实现这个方法只需要这两个类：

class Vicki: Speaker {
  func Speak() {
    println("Hello, I am Vicki!")
  }
  func TellJoke() {
    println("Q: What did Sushi A say to Sushi B?")
  }
}
 
class Ray: Speaker {
  func Speak() {
    println("Yo, I am Ray!")
  }
  func TellJoke() {
    println("Q: Whats the object-oriented way to become wealthy?")
  }
  func WriteTutorial() {
    println("I'm on it!")
  }
}

注意当你实现一个协议的时候，在协议里你的类当然可以有更多的方法，而不是只有一个，如果你需要的话。这里**Ray**类有一个额外的方法。

噢，你能猜猜这些玩笑话的答案吗？

这里面有解决方案：

Q: What did Sushi A say to Sushi B? A: Wasabi!
Q: Whats the object-oriented way to become wealthy? A: Inheritance!

##使用协议

现在我们创建了一个协议和一些类并且实现了它们，让我们尝试使用它们。在你的playground中添加以下几行代码：

var speaker:Speaker
speaker = Ray()
speaker.Speak()
// speaker.WriteTutorial() // error!
(speaker as Ray).WriteTutorial()
speaker = Vicki()
speaker.Speak()

注意与其声明**speaker**为**Ray**,不如声明它为**speaker**。这意味着你只能当**Speaker**协议存在时调用**speaker**方法，所以调用**WriteTutorial**会导致错误即使**speaker**实际上是一个Ray类型。你可以调用**WriteTutorial**,如果你暂时将speaker投向**Ray**，就像你现在看到的。

同时注意你也可以设置speaker为**Vicki**，因为**Vicki**也遵守**Speaker**协议。

现在加上这几行代码来试验一下可选方法：

speaker.TellJoke?()
speaker = Dog()
speaker.TellJoke?()

要记住** TellJoke**是一个可选方法，所以当你调用它的时候要检查一下它是否存在。

这些代码使用了一种叫做**可选链接**的技术来做这件事。







